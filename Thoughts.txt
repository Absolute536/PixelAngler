Let's organise our thoughts here.

Future reference for implementing other functionalities
- CanvasModulate Node for day/night cycle
- Object pooling for the fishing line or other objects (maybe not the fishing line cuz it's only one)

State Management
- So state machine has a collection of states and transitions between each of them
- And the logic for the behaviours in each state should be contained within the implemented State scripts

IDLE -- directional movement --> WALKING
IDLE -- left mouse --> ITEM_ACTION
WALKING -- left mouse --> IDLE (then immediately IDLE detects the left mouse and transitions to ITEM_ACTION)

Walking State
- Directional movement
- If no movement, transitions to Idle
- If mouse click, transitions to Idle, then to ItemAction (or straight away to Item Action)?
- (07/10) Mouse click, transitions to Idle, then immediately to Action (renamed) if click is held down

Action State
- ok, let's clear things up here.
- entering action state, check which item is selected
- then invoke the selected item's action???
  -> instantiate the scene/node?
  -> add to player
  -> OH, OK. because it's PLAYER'S state, so it must be tied to player
  -> like player is the "target"
  -> I think we can create an action manager to hold the player's reference and make it a child of the player.
  -> then the manager shall manage the actions
  -> ok, let's test it out.

Cast Marker
- 2 options -> instantiate scene when needed or attach it to player from the very beginning
- operations
- start from player's position + 2 tile to whatever direction the player is facing
- if LMB is held, move the marker's position by increments of 1 tile every t (seconds), up to a max
- upon release, the marker either
  -> reset position to the initial one and hide itself
  -> queue free it
- there is also the need of an indicator as well for the marker
- UPDATE: ok, the cast marker works now, and it's pretty clean, with the ActionManager
- NEXT: implement location detection of the marker when the mouse button is released
- on release: get position, get location (Tiletype), then the position will be the end point for bobber (start point - player origin + 32 or 16?)
- to account for the player's height

Extending from cast marker, we continue to the casting of the bobber and line itself
- upon LMB release of the marker, the final position of the marker is recorded
- depending on the facing direction, the bobber either
  -> move in the opposite direction then to the specified position (vertical)
  -> move in a parabolic curve according to the projectile motion (horizontal)
- the fishing line should also be attached to the bobber as it moves according to:
  -> quadratic beizer curve (complicated)
  -> just a simple parabolic curve?
  -> the built in setting for LineJointMode (idk if this works)

  Autoload
  - the singleton pattern
  - the autoload objects (nodes) will be loaded to the scene tree [always]
  - so we can either like
  - signal bus [reddit idea] => have the subscriber subscribe to the relevant delegates
  - OR master scene => contain wrapper methods for the necessary function within the nodes in scene
  - OR just make World a autoload node

Autoload Continuation
- OK. Let's do it this way.
- GlobalManager -> contain reference of World and provide wrapper methods for other classes to access the methods in World
- SignalBus -> contain a series of events/delegates for when we need one to many notification to the subscribers

Bobber Physics
- Parabolic curve (quadratic graph) -> end point as a root, start point as the axis of symmetry, then find another root, derive function
- problem: it is kinda static, since the start point is the maximum point, the bobber won't act like a projectile that much

- Use projectile motion instead
- calculate and set the position of bobber in each physics process frame
- calculate displacement of x and y from the start point 
- problem: can't fully align to end point and need to adjust gravity and initial velocity parameters to make it feel right
- solution: manipulate the formula instead
- calculate initial velocity from the end point
- x is known, t is fixed as 0.5 (make the casting duration only 0.5)
- rearrange them to get the initial velocity
- then we do this for every cast to dynamically calculate the correct initial velocity (u) for ensuring the bobber will land at the end point AND follows the correct trajectory
- welp, try it later Imma sleep now
- Yup. It works

Input Related problem
- The Input singleton bypasses the input event propagation hierarchy
- SO, that's why moving the cast action to _UnhandledInput() didn't work [WRONG!]
- BECAUSE, some other part, in the PhysicsProcess() consumed it as it was checking for Input.IsActionPressed()
- Example: in the IDLE state transition
- OK. The above statements are kinda wrong
- Previously, in playeractionstate, we handled the mouse input to trigger the casting action through UnhandledInput()
- BUT! Then, we moved it to the HandleInput function, which is received by the state machine, so the OnPressed mouse input is consumed at the state machine
- It couldn't reach the playeractionstate to trigger the start of the casting action(?)
- OK AGAIN!
- Now I know why. When I pressed Action, the state is in idle, and it invokes the HandleInput of Idle, instead of Action, so the action state can't detect
- the consumed input by the state machine
- So, now when it's in the Action state, the mouse is held, but the input is already consumed, so it'll only detect the OnActionReleased.
- DING DING DING DING DING
- OKAYYYYYYYYYYYY~~~~~~
- Now. We should organise it well from the very beginning huh ~
- Let's try this.
- Movement based input, we probably need polling, so into PhysicsProcess it goes
- Mouse based input, it is event based, so maybe we put them in UnhandledInput
- But then, the main problem is the input event being consumed in an unwanted state, so we need some way to circumvent that.
- so we need some way to ensure the input event from the previous state persists into the next state
- I mean, we can just use the Input singleton to make this work, but then it ignores input event propagation, so that's a problem as well
- Yeah, so upon any input, the HandleInput() of the current state will be invoked because the Input singleton doesn't actually consume the input event
- OKAYYYYY!!!!
- there is an IsEcho() method for InputEvent
- so we can check this for key hold (kinda I guess)
- welp..... It doesn't really work
- I guess the solution now is to go with using the Input singleton AND implement some pausing mechanism if when an UI element is focused.
- That'll be more straight-forward
- BUT, it can't be done.....
- If I use the Input singleton, then what would happen if I want to use mouse button for selected item on the inventory tab
- Input won't consume the input event, only when you are handling it using the Input Callbacks
- FUCKKKKKK
- Yeah, WhAtEvEr. Let's just use the Input singleton for now. Leave that to future me
- one solution is to check if a particular UI node has focus when handling the input (but introduces dependency)
- Oh, ok. There's a solution. Just create a new state, something like InUI or whatever, where you won't handle input, and transition to that state upon opening a menu or some shit.
- OHHH, or another possible solution.
- include the data parameter on enter state and state transition event, include something that can differentiate button held in PlayerActionState.

- WHAT A FUCKING DUMBASS THAT I AM
- Just make the PlayerActionState trigger StartAction() upon entering the state, PROBLEM SOLVED (you'd want this anyway)
- Can't believe I wasted 3 hours looking up workarounds and shit.
- Damn...

- Yep.... Me again.
- It works, but not for the Walking state. It's a lot of extra work and workarounds.
- Nvm then. I'll just use the Input singleton and create an extra flag or a new state when handling UI.

- Refactor to Various action state instead
- Why not remove the action state entirely and transition from idle to the respective state based on SelectedItem?

- What we want:
- on click, to casting state
- start the casting action
- end the casting action, 
- instantiate line and bobber to end position
- get TileType, if on water, transition to fishing state

- bobber we also add to the player scene, but hide it first
- maintain the current implementation, just that we disable the physics process once the end point is reached

- 19/10/2025 (4:42 am)
- NOW! We need to refine the casting process to ensure it's seamless
- Continue ~
- Next steps
- on click release - cast bobber & line
- if not on water, go back to idle state, reset bobber and line as well
- if on water, go to fishing state or angling state for the timing event?

- OK!!!!
- Now we set the ground rules(?)
- For node references within the same scene (has a common ancestor) -> we use Exported properties to get the reference
- For invoking methods of nodes in external scene -> we use the SignalBus OR Node Group
- For SignalBus, it is better if the nodes we want to notify has no correlation
- For Node Group, it is better when we want to notify multiple similar nodes (like notifying a bunch of enemy nodes in the scene during runtime)

- Fishing line time
- using quadratic beizer curve (kinda difficult)
- I plotted the line, but it doesn't "curve"
- easier alternative, use a parabolic curve, with the bobber position as the minimum point

- Both bobber and fishing line works now, just need to polish them
- Bobber needs casting TOWARDS the destination and reeling BACK from the destination
- Fishing line needs more decoupling (maybe). I would like to call it from the casting state, instead of couple it within the Bobber classes

- Update for floating point value problem
- The reverse path of the bobber projectile will not coincide if x is 0. or -1. or 1., where the fractional part is .3333 or .6777 (I think)
- I suppose it is the same for the y axis as well, though I can't prove it
- because when input change, we apply jitter fix, which will round the vector
- I think rounding it will work, because we only sample per delta += 0.016666667....
- so each "step" will have rather significant differences, and so they won't colide (I think)
- yeap, rounding does work, but it FEELS kinda wrong

- State transitions
- idle to walk -> no lmb and movement
- walk to idle -> lmb just pressed or no movement
- idle to casting -> lmb pressed
- casting to idle -> release (not on water)
- casting to fishing -> release (on water)
- fishing to idle -> lmb just pressed (this is where the problem's at, doable if we use some sort of signal to wait)
- let's try using some sort of signal to wait until the bobber motion is done
- UPDATE: yeah it all works seamlessly now

Now, on to the fishing gameplay
- first the timing element.
- bobber land in water -> FishingState
- after (Fixed) seconds, a fish silhouette spawns
- after spawnning in, start the strike timer with (Random) seconds
- during this time, the fish will move randomly, trying to nibble on the bait
- on striker timer timeout, fish moves into the bobber, biting it
- after biting it, player has to LMB within (Fixed) second to actually start the minigame
- success -> start minigame (maybe transition into game state?)
- failure -> reset and repeat the above
- Fishing State reel back: if not strike timer not yet timeout, can reel back, else, nope

QTE Elements
- trigger condition: bobber land on water
- input window: LMB within the specified duration
- duration: 0.7s
- on success: initiate minigame
- on failure: repeat

- no need to cancel
- cast -> wait (for a random duration) -> start the fish spawnning animation/mechanism
- reel back before fish bite -> cancel fish animation
- fish bite -> start QTE -> success: start minigame, failure: repeat the fish spawnning animation
- so no need for cancelling QTE, but the fish animation itself

- testing out enforce pull request
- another

- FishNibbleState
- On Enter:
- Get bobber reference
- Set fish position at a random distance away from bobber --> need to account for facing direction
- start the nibble timer
- initialise the nibble parameters
- total nibble required, current nibble count = 0, nibble speed (this one can be on each nibble start)
- Nibble Timer Timeout:
- start the motion by flipping isActive to true
- On collision with bobber:
- bounce(?) away from bobber until it reaches a specified random distance? and stops
- upon stopping, restart the movement towards bobber with a randomised speed
- So basically repeat until current nibble count == total nibble required
- afterthat, repeat once more (or at total nibble required - 1?), and on area entered, start the qte
- success: transition to game -> and then the fish would also need to register to an event raised by the bobber to follow its movement
- failure: queue free the fish ---> wait random time for another fish to spawn to repeat the process

- random idea: flip the fish sprite while in certain action (pull away flip, move towards, flip back)
- yeah, just proceed with a simple one (follow straight line) for now. (no need for anything complex like A* search or whatever) can revisit if have extra time (Lol)
- just made fish a child of bobber, so we can just manipulate bobber, and the fish will follow (once it's hooked)
- potential solution, create area2d around bobber on landing, and check for collision based on the radius (distance)
- if no collision with edges (as in water edges), then it's safe
- holdddddd!!!! maybe raycast is a potential solution?
- try raycasting to from bobber to the fish spawn location. If no collision reported, then we're safe (yeah, it works if there's a random patch of land as well)
- YEAHHHHHH!!!! raycast WORKSSSSS!!
- so we use raycast then
- hmm... can't use a while loop to search for spawn point cuz of the engine right, it will cause suspension (try again)
- potential soluion:
- enforce spawn direction is facing direction along bobber (like before)
- get angle, get spawn location (like before)
- if fail, try another direction until all 4 directions are attempted
- OR
- use shapecast2D in a circle around bobber
- set radius = random distance
- if no collision, then can spawn anywhere within the circle minus a 1 tile radius (for safety)
- also we set enabled = false by default, then only enabled = true when bobber lands on water (idk if this "saves" anything)
- OK, let's go with this tmr (turu dulu bang)
- hmm... unfortunately, it doesn't really work like I think would work
- OR (new)
- use another area2d in the bobber specifically for detecting collision with
- you know what, nvm, let's just go with the original raycast, cuz with shapes, we can't exactly determine the direction.

- additional: wander state first before nibble?

= REVAMP FISH SPAWNNING =
- use a spawn point that is placed in water (manually) instead
- then the fish spawns from the point and enter into wander state, where they can move around and not onto grass or whatever

- Fonts
- https://openfontlicense.org/
- https://www.dafont.com/press-start.font
- https://www.zone38.net/font/
- Use PressStart font currently (just for fun)
- License information states it's free to use without accredition or including the license (only restriction is you can't claim copyright, or sell the font by itself I think)

- let bobber have an InWater event
- all fish subscribe to this event upon spawnning
- if out of water, raise the event, and transition fish to wander state

FishAttractedState
- Damn it gonna go back to square one again
- steps
- get bobber location
- discover opposite of fish to bobber direction (most likely have empty space)
- again, random angle to get random point
- use the "duration" trick, and let the collision handle it

- WAIT
- big problem
- what if there are obstacles in the water?
- damn, do we really need to use A*
- or maybe navigationmesh2d?
- You know. Let's put this aside first and stick with the current one
- Or else, I'll never get this thing done.

- Note: probably need a raycast in Fish
- if raycast detected collision in the direction of bobber, don't transit to nibble state (crisis averted)

07/12/2025
- IMPORTANT NOTE: on ExitTree, only disconnect the signals connected to the SignalBus?
- Yup, not need to explicitly disconnect, cuz it's all already handled in the Enter Exit State Cycle

Save file
- Player position
- current time (in-game minutes passed) --> _time field
- catch progress
- maybe I can put a game settings here as well OR, make a config file (yeah, we'll use a config file I guess)

- VERY IMPORTANT
- may need to readjust the size of the fishing catalogue if we want to account for a longer fish name (in the future)

- Why am I so stupid
- IT'S "F2", NOT "2F" to format float in string
- Stupid (wasted 20 minutes of my time, GREAT.)

- yeah, also remember to adjust the bobber's area, so that other fish won't detect is while hooked
- Aight DONE

Audio
-> bgm, use some classical music (like those more soothing? ones from Blockheads, I miss you TAT)
-> sfx, player sound effect (action), world (the ambient(if possible)), game sfx (globally)
-> so need 1 player + 1 bgm + 1 sfx + 1 ambient = 4 total audiostreamplayers(?)
-> guess I'll use a 4 audio stream players in the autoload and just 
-> maybe not, for the sfx, probably gonna instantiate on demand? And just pool the bgm, player (like action sound), and maybe ambient (switch out for diff. location)
-> then in autoload I'll have a playsfx(parent, what you want to play) for sfx and add child to parent, then connect to finished signal to free itself
-> player action also on demand I guess;
-> Scrapped ambience sounds, cuz too distracting
-> Ok, maybe can add it back IF we have extra time
-> New idea is let the player control the changing of ambience sounds by emiting signals to audio manager on location change
-> yeah, it's right there. Guess my brain turned to mush after 1 night of 0 sleep. (YaY)

DONE
- finally done with drawing all those animations and fish sprites
- everything's working now.
- it's finished, I guess
- still more room for improvement
-> a help manual
-> decorate the pause menu
-> dynamic audio,especially for the walking sound
-> there is also a slight flaw in the playing of the fishing sfx, if you hold while in red then green, progress will increase, but the sfx will be off
   -> probably cuz we use unhandled_input for the playing of sfx
-> parameters for each of the species can be fine tuned more
-> and YEAH.... a main menu, a loading screen, ...
==> well, I'll move on first to ensure we can finish this whole project
==> we'll come back later if we have extra time (YOU KNOW DAMN WELL THERE ISN'T)