Let's organise our thoughts here.

Future reference for implementing other functionalities
- CanvasModulate Node for day/night cycle
- Object pooling for the fishing line or other objects (maybe not the fishing line cuz it's only one)

State Management
- So state machine has a collection of states and transitions between each of them
- And the logic for the behaviours in each state should be contained within the implemented State scripts

IDLE -- directional movement --> WALKING
IDLE -- left mouse --> ITEM_ACTION
WALKING -- left mouse --> IDLE (then immediately IDLE detects the left mouse and transitions to ITEM_ACTION)

Walking State
- Directional movement
- If no movement, transitions to Idle
- If mouse click, transitions to Idle, then to ItemAction (or straight away to Item Action)?
- (07/10) Mouse click, transitions to Idle, then immediately to Action (renamed) if click is held down

Action State
- ok, let's clear things up here.
- entering action state, check which item is selected
- then invoke the selected item's action???
  -> instantiate the scene/node?
  -> add to player
  -> OH, OK. because it's PLAYER'S state, so it must be tied to player
  -> like player is the "target"
  -> I think we can create an action manager to hold the player's reference and make it a child of the player.
  -> then the manager shall manage the actions
  -> ok, let's test it out.

Cast Marker
- 2 options -> instantiate scene when needed or attach it to player from the very beginning
- operations
- start from player's position + 2 tile to whatever direction the player is facing
- if LMB is held, move the marker's position by increments of 1 tile every t (seconds), up to a max
- upon release, the marker either
  -> reset position to the initial one and hide itself
  -> queue free it
- there is also the need of an indicator as well for the marker
- UPDATE: ok, the cast marker works now, and it's pretty clean, with the ActionManager
- NEXT: implement location detection of the marker when the mouse button is released
- on release: get position, get location (Tiletype), then the position will be the end point for bobber (start point - player origin + 32 or 16?)
- to account for the player's height

Extending from cast marker, we continue to the casting of the bobber and line itself
- upon LMB release of the marker, the final position of the marker is recorded
- depending on the facing direction, the bobber either
  -> move in the opposite direction then to the specified position (vertical)
  -> move in a parabolic curve according to the projectile motion (horizontal)
- the fishing line should also be attached to the bobber as it moves according to:
  -> quadratic beizer curve (complicated)
  -> just a simple parabolic curve?
  -> the built in setting for LineJointMode (idk if this works)

  Autoload
  - the singleton pattern
  - the autoload objects (nodes) will be loaded to the scene tree [always]
  - so we can either like
  - signal bus [reddit idea] => have the subscriber subscribe to the relevant delegates
  - OR master scene => contain wrapper methods for the necessary function within the nodes in scene
  - OR just make World a autoload node

Autoload Continuation
- OK. Let's do it this way.
- GlobalManager -> contain reference of World and provide wrapper methods for other classes to access the methods in World
- SignalBus -> contain a series of events/delegates for when we need one to many notification to the subscribers

Bobber Physics
- Parabolic curve (quadratic graph) -> end point as a root, start point as the axis of symmetry, then find another root, derive function
- problem: it is kinda static, since the start point is the maximum point, the bobber won't act like a projectile that much

- Use projectile motion instead
- calculate and set the position of bobber in each physics process frame
- calculate displacement of x and y from the start point 
- problem: can't fully align to end point and need to adjust gravity and initial velocity parameters to make it feel right
- solution: manipulate the formula instead
- calculate initial velocity from the end point
- x is known, t is fixed as 0.5 (make the casting duration only 0.5)
- rearrange them to get the initial velocity
- then we do this for every cast to dynamically calculate the correct initial velocity (u) for ensuring the bobber will land at the end point AND follows the correct trajectory
- welp, try it later Imma sleep now
- Yup. It works

Input Related problem
- The Input singleton bypasses the input event propagation hierarchy
- SO, that's why moving the cast action to _UnhandledInput() didn't work [WRONG!]
- BECAUSE, some other part, in the PhysicsProcess() consumed it as it was checking for Input.IsActionPressed()
- Example: in the IDLE state transition
- OK. The above statements are kinda wrong
- Previously, in playeractionstate, we handled the mouse input to trigger the casting action through UnhandledInput()
- BUT! Then, we moved it to the HandleInput function, which is received by the state machine, so the OnPressed mouse input is consumed at the state machine
- It couldn't reach the playeractionstate to trigger the start of the casting action(?)
- OK AGAIN!
- Now I know why. When I pressed Action, the state is in idle, and it invokes the HandleInput of Idle, instead of Action, so the action state can't detect
- the consumed input by the state machine
- So, now when it's in the Action state, the mouse is held, but the input is already consumed, so it'll only detect the OnActionReleased.
- DING DING DING DING DING
- OKAYYYYYYYYYYYY~~~~~~
- Now. We should organise it well from the very beginning huh ~
- Let's try this.
- Movement based input, we probably need polling, so into PhysicsProcess it goes
- Mouse based input, it is event based, so maybe we put them in UnhandledInput
- But then, the main problem is the input event being consumed in an unwanted state, so we need some way to circumvent that.
- so we need some way to ensure the input event from the previous state persists into the next state
- I mean, we can just use the Input singleton to make this work, but then it ignores input event propagation, so that's a problem as well
- Yeah, so upon any input, the HandleInput() of the current state will be invoked because the Input singleton doesn't actually consume the input event
- OKAYYYYY!!!!
- there is an IsEcho() method for InputEvent
- so we can check this for key hold (kinda I guess)
- welp..... It doesn't really work
- I guess the solution now is to go with using the Input singleton AND implement some pausing mechanism if when an UI element is focused.
- That'll be more straight-forward
- BUT, it can't be done.....
- If I use the Input singleton, then what would happen if I want to use mouse button for selected item on the inventory tab
- Input won't consume the input event, only when you are handling it using the Input Callbacks
- FUCKKKKKK
- Yeah, WhAtEvEr. Let's just use the Input singleton for now. Leave that to future me
- one solution is to check if a particular UI node has focus when handling the input (but introduces dependency)
- Oh, ok. There's a solution. Just create a new state, something like InUI or whatever, where you won't handle input, and transition to that state upon opening a menu or some shit.
- OHHH, or another possible solution.
- include the data parameter on enter state and state transition event, include something that can differentiate button held in PlayerActionState.

- WHAT A FUCKING DUMBASS THAT I AM
- Just make the PlayerActionState trigger StartAction() upon entering the state, PROBLEM SOLVED (you'd want this anyway)
- Can't believe I wasted 3 hours looking up workarounds and shit.
- Damn...